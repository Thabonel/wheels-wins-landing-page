"""
Sub-Agent Orchestrator - Planner/Executor Pattern.

Implements Principle 7: Sub-Agent Scoping.
Planner sees broad context (goals, history), Executor sees narrow context (current step, tools).
"""

import json
import logging
import os
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Callable, Dict, List, Optional
from uuid import UUID

from anthropic import AsyncAnthropic
from supabase import create_client

from .context_compiler import CompilationConfig, CompiledContext, ContextCompiler

logger = logging.getLogger(__name__)


class TaskComplexity(Enum):
    """Task complexity levels for routing decisions."""

    SIMPLE = "simple"  # Direct response, no planning needed
    MODERATE = "moderate"  # Some planning, single tool call
    COMPLEX = "complex"  # Full planner/executor flow


@dataclass
class ExecutionStep:
    """A single step in an execution plan."""

    step_number: int
    description: str
    tool_to_use: Optional[str] = None
    tool_parameters: Dict[str, Any] = field(default_factory=dict)
    expected_output: str = ""
    fallback: str = ""
    status: str = "pending"  # pending, in_progress, completed, failed
    result: Optional[Any] = None
    error: Optional[str] = None


@dataclass
class ExecutionPlan:
    """Plan generated by the Planner agent."""

    steps: List[ExecutionStep]
    required_tools: List[str]
    estimated_complexity: TaskComplexity
    constraints: Dict[str, Any]
    success_criteria: List[str]
    reasoning: str = ""


@dataclass
class ExecutionResult:
    """Result of executing a single step."""

    step_number: int
    success: bool
    output: Any = None
    error: Optional[str] = None
    tool_used: Optional[str] = None
    duration_ms: float = 0.0


@dataclass
class OrchestrationResult:
    """Final result of the full orchestration flow."""

    success: bool
    response: str
    plan: Optional[ExecutionPlan] = None
    execution_results: List[ExecutionResult] = field(default_factory=list)
    total_duration_ms: float = 0.0
    complexity: TaskComplexity = TaskComplexity.SIMPLE


PLANNER_SYSTEM_PROMPT = """You are PAM's Planning Agent. Your role is to analyze user requests and create structured execution plans.

You have access to these tools for the Executor to use:
{available_tools}

Given a user request, output a JSON execution plan following this schema:
```json
{{
  "reasoning": "Brief explanation of your approach",
  "steps": [
    {{
      "step_number": 1,
      "description": "What to do in this step",
      "tool_to_use": "tool_name or null for conversation",
      "tool_parameters": {{}},
      "expected_output": "What we expect",
      "fallback": "What to do if this fails"
    }}
  ],
  "required_tools": ["list of tools needed"],
  "estimated_complexity": "simple|moderate|complex",
  "constraints": {{"budget": null, "time": null}},
  "success_criteria": ["How we know the task is complete"]
}}
```

RULES:
1. Keep plans minimal - use fewest steps necessary
2. Simple queries (greetings, facts) need no tools
3. Only include steps that require action
4. Be specific about tool parameters
5. Output ONLY valid JSON"""

EXECUTOR_SYSTEM_PROMPT = """You are PAM's Execution Agent. Your role is to execute ONE step of an execution plan.

CURRENT STEP TO EXECUTE:
{current_step}

PREVIOUS RESULTS:
{previous_results}

AVAILABLE TOOL:
{tool_info}

Your task:
1. Execute this specific step
2. Use the tool if specified, or provide a direct response
3. Report the result clearly

If using a tool, output JSON:
```json
{{
  "action": "tool_call",
  "tool_name": "tool_name",
  "parameters": {{}}
}}
```

If providing a direct response (no tool needed):
```json
{{
  "action": "response",
  "content": "Your response here"
}}
```

If the step failed:
```json
{{
  "action": "error",
  "error": "What went wrong",
  "fallback_suggestion": "What to try next"
}}
```"""

COMPLEXITY_CLASSIFIER_PROMPT = """Classify this user request by complexity:

REQUEST: {request}

AVAILABLE TOOLS: {tools}

Output JSON:
```json
{{
  "complexity": "simple|moderate|complex",
  "reasoning": "Why this classification",
  "needs_planning": true/false,
  "suggested_approach": "brief description"
}}
```

- SIMPLE: Greetings, factual questions, no tools needed
- MODERATE: Single tool call, clear intent
- COMPLEX: Multiple steps, multiple tools, or unclear intent"""


class SubAgentOrchestrator:
    """
    Orchestrates Planner and Executor agents with scoped contexts.

    Flow for complex requests:
    1. Classify complexity
    2. If complex: Run Planner (broad context) -> Get plan
    3. For each step: Run Executor (narrow context) -> Execute
    4. Synthesize results into user response

    Simple requests skip directly to response generation.
    """

    def __init__(
        self,
        context_compiler: Optional[ContextCompiler] = None,
        tool_executor: Optional[Callable] = None,
        embeddings_service=None,
    ):
        """
        Initialize orchestrator.

        Args:
            context_compiler: For compiling scoped contexts
            tool_executor: Function to execute tools (tool_name, params) -> result
            embeddings_service: For generating embeddings
        """
        self.context_compiler = context_compiler or ContextCompiler(embeddings_service)
        self.tool_executor = tool_executor
        self.embeddings_service = embeddings_service

        self.supabase = create_client(
            os.getenv("SUPABASE_URL", ""),
            os.getenv("SUPABASE_SERVICE_ROLE_KEY", ""),
        )

        self.anthropic = AsyncAnthropic(api_key=os.getenv("ANTHROPIC_API_KEY"))
        self.model = "claude-sonnet-4-5-20250929"

    async def process_request(
        self,
        user_id: UUID,
        session_id: UUID,
        request: str,
        available_tools: List[Dict],
    ) -> OrchestrationResult:
        """
        Main entry point: Process a user request through the orchestration flow.

        Args:
            user_id: User identifier
            session_id: Current session identifier
            request: User's natural language request
            available_tools: List of available tool definitions

        Returns:
            OrchestrationResult with response and execution details
        """
        start_time = datetime.utcnow()

        logger.info(f"Processing request for user {user_id}: {request[:50]}...")

        # Step 1: Classify complexity
        complexity = await self._classify_complexity(request, available_tools)

        logger.info(f"Request classified as: {complexity.value}")

        # Step 2: Route based on complexity
        if complexity == TaskComplexity.SIMPLE:
            # Skip planning, generate direct response
            result = await self._handle_simple_request(
                user_id, session_id, request, available_tools
            )
        elif complexity == TaskComplexity.MODERATE:
            # Light planning, single execution
            result = await self._handle_moderate_request(
                user_id, session_id, request, available_tools
            )
        else:
            # Full planner/executor flow
            result = await self._handle_complex_request(
                user_id, session_id, request, available_tools
            )

        result.complexity = complexity
        result.total_duration_ms = (
            datetime.utcnow() - start_time
        ).total_seconds() * 1000

        logger.info(
            f"Request completed: complexity={complexity.value}, "
            f"success={result.success}, duration={result.total_duration_ms:.1f}ms"
        )

        return result

    async def _classify_complexity(
        self, request: str, available_tools: List[Dict]
    ) -> TaskComplexity:
        """Classify request complexity to determine routing."""
        tool_names = [t.get("name", "") for t in available_tools]

        prompt = COMPLEXITY_CLASSIFIER_PROMPT.format(
            request=request, tools=", ".join(tool_names)
        )

        try:
            response = await self.anthropic.messages.create(
                model=self.model,
                max_tokens=500,
                messages=[{"role": "user", "content": prompt}],
            )

            response_text = response.content[0].text.strip()

            # Parse JSON response
            if "```" in response_text:
                response_text = response_text.split("```")[1]
                if response_text.startswith("json"):
                    response_text = response_text[4:]
                response_text = response_text.strip()

            result = json.loads(response_text)
            complexity_str = result.get("complexity", "moderate").lower()

            return TaskComplexity(complexity_str)

        except Exception as e:
            logger.warning(f"Complexity classification failed: {e}, defaulting to moderate")
            return TaskComplexity.MODERATE

    async def _handle_simple_request(
        self,
        user_id: UUID,
        session_id: UUID,
        request: str,
        available_tools: List[Dict],
    ) -> OrchestrationResult:
        """Handle simple requests with direct response (no planning)."""
        # Compile minimal context
        config = CompilationConfig(
            agent_scope="default",
            max_recent_events=5,
            max_memories=2,
            max_total_tokens=4000,
        )

        context = await self.context_compiler.compile_context(
            agent_id="pam_simple",
            user_id=user_id,
            current_task=request,
            session_id=session_id,
            config=config,
        )

        messages = context.to_messages()
        messages.append({"role": "user", "content": request})

        try:
            response = await self.anthropic.messages.create(
                model=self.model,
                max_tokens=1000,
                messages=messages,
            )

            return OrchestrationResult(
                success=True,
                response=response.content[0].text,
            )

        except Exception as e:
            logger.error(f"Simple request failed: {e}")
            return OrchestrationResult(
                success=False,
                response=f"Sorry, I encountered an error: {str(e)}",
            )

    async def _handle_moderate_request(
        self,
        user_id: UUID,
        session_id: UUID,
        request: str,
        available_tools: List[Dict],
    ) -> OrchestrationResult:
        """Handle moderate requests with light planning."""
        # Use planner context but expect single-step plan
        plan = await self._run_planner(user_id, session_id, request, available_tools)

        if not plan or not plan.steps:
            # Fall back to simple handling
            return await self._handle_simple_request(
                user_id, session_id, request, available_tools
            )

        # Execute first step only (moderate = single step)
        execution_results = []
        if plan.steps:
            result = await self._run_executor(
                user_id, session_id, plan, plan.steps[0], available_tools, []
            )
            execution_results.append(result)

        # Generate final response
        response = await self._synthesize_response(
            user_id, session_id, request, plan, execution_results
        )

        return OrchestrationResult(
            success=all(r.success for r in execution_results),
            response=response,
            plan=plan,
            execution_results=execution_results,
        )

    async def _handle_complex_request(
        self,
        user_id: UUID,
        session_id: UUID,
        request: str,
        available_tools: List[Dict],
    ) -> OrchestrationResult:
        """Handle complex requests with full planner/executor flow."""
        # Step 1: Run Planner
        plan = await self._run_planner(user_id, session_id, request, available_tools)

        if not plan:
            return OrchestrationResult(
                success=False,
                response="I couldn't create a plan for this request. Could you rephrase it?",
            )

        logger.info(f"Plan created: {len(plan.steps)} steps, tools: {plan.required_tools}")

        # Step 2: Execute each step
        execution_results = []
        for step in plan.steps:
            result = await self._run_executor(
                user_id, session_id, plan, step, available_tools, execution_results
            )
            execution_results.append(result)

            # Stop on critical failure
            if not result.success and step.fallback == "abort":
                logger.warning(f"Execution aborted at step {step.step_number}")
                break

        # Step 3: Synthesize response
        response = await self._synthesize_response(
            user_id, session_id, request, plan, execution_results
        )

        return OrchestrationResult(
            success=all(r.success for r in execution_results),
            response=response,
            plan=plan,
            execution_results=execution_results,
        )

    async def _run_planner(
        self,
        user_id: UUID,
        session_id: UUID,
        request: str,
        available_tools: List[Dict],
    ) -> Optional[ExecutionPlan]:
        """Run Planner agent with broad scope context."""
        # Compile planner context (Principle 7: broad scope)
        config = CompilationConfig(
            agent_scope="planner",
            max_recent_events=5,  # Less detail, more overview
            max_memories=3,
            max_total_tokens=8000,
        )

        context = await self.context_compiler.compile_context(
            agent_id="pam_planner",
            user_id=user_id,
            current_task=request,
            session_id=session_id,
            config=config,
        )

        # Format available tools for planner
        tools_description = self._format_tools_for_planner(available_tools)

        system_prompt = PLANNER_SYSTEM_PROMPT.format(available_tools=tools_description)

        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "system", "content": f"User profile: {context.user_profile_summary}"},
        ]

        # Add session context if available
        if context.session_summary:
            summary_text = f"Session context: {json.dumps(context.session_summary)}"
            messages.append({"role": "system", "content": summary_text})

        messages.append({"role": "user", "content": f"Create a plan for: {request}"})

        try:
            response = await self.anthropic.messages.create(
                model=self.model,
                max_tokens=2000,
                messages=messages,
            )

            response_text = response.content[0].text.strip()

            # Parse JSON response
            if "```" in response_text:
                response_text = response_text.split("```")[1]
                if response_text.startswith("json"):
                    response_text = response_text[4:]
                response_text = response_text.strip()

            plan_data = json.loads(response_text)

            # Build ExecutionPlan
            steps = [
                ExecutionStep(
                    step_number=s.get("step_number", i + 1),
                    description=s.get("description", ""),
                    tool_to_use=s.get("tool_to_use"),
                    tool_parameters=s.get("tool_parameters", {}),
                    expected_output=s.get("expected_output", ""),
                    fallback=s.get("fallback", "continue"),
                )
                for i, s in enumerate(plan_data.get("steps", []))
            ]

            complexity_str = plan_data.get("estimated_complexity", "moderate")
            try:
                complexity = TaskComplexity(complexity_str)
            except ValueError:
                complexity = TaskComplexity.MODERATE

            return ExecutionPlan(
                steps=steps,
                required_tools=plan_data.get("required_tools", []),
                estimated_complexity=complexity,
                constraints=plan_data.get("constraints", {}),
                success_criteria=plan_data.get("success_criteria", []),
                reasoning=plan_data.get("reasoning", ""),
            )

        except Exception as e:
            logger.error(f"Planner failed: {e}")
            return None

    async def _run_executor(
        self,
        user_id: UUID,
        session_id: UUID,
        plan: ExecutionPlan,
        step: ExecutionStep,
        available_tools: List[Dict],
        previous_results: List[ExecutionResult],
    ) -> ExecutionResult:
        """Run Executor agent with narrow scope context."""
        start_time = datetime.utcnow()

        # Compile executor context (Principle 7: narrow scope)
        config = CompilationConfig(
            agent_scope="executor",
            max_recent_events=3,  # Very focused
            max_memories=2,
            max_total_tokens=4000,
        )

        context = await self.context_compiler.compile_context(
            agent_id="pam_executor",
            user_id=user_id,
            current_task=step.description,
            session_id=session_id,
            config=config,
        )

        # Get tool info if needed
        tool_info = "No tool needed for this step"
        if step.tool_to_use:
            tool_def = next(
                (t for t in available_tools if t.get("name") == step.tool_to_use), None
            )
            if tool_def:
                tool_info = json.dumps(tool_def, indent=2)

        # Format previous results
        prev_results_text = "None"
        if previous_results:
            prev_results_text = "\n".join(
                f"Step {r.step_number}: {'SUCCESS' if r.success else 'FAILED'} - {r.output or r.error}"
                for r in previous_results
            )

        system_prompt = EXECUTOR_SYSTEM_PROMPT.format(
            current_step=json.dumps(
                {
                    "step_number": step.step_number,
                    "description": step.description,
                    "tool_to_use": step.tool_to_use,
                    "tool_parameters": step.tool_parameters,
                    "expected_output": step.expected_output,
                }
            ),
            previous_results=prev_results_text,
            tool_info=tool_info,
        )

        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": "Execute this step now."},
        ]

        try:
            response = await self.anthropic.messages.create(
                model=self.model,
                max_tokens=1500,
                messages=messages,
            )

            response_text = response.content[0].text.strip()

            # Parse JSON response
            if "```" in response_text:
                response_text = response_text.split("```")[1]
                if response_text.startswith("json"):
                    response_text = response_text[4:]
                response_text = response_text.strip()

            result_data = json.loads(response_text)
            action = result_data.get("action", "response")

            if action == "tool_call" and self.tool_executor:
                # Execute tool
                tool_name = result_data.get("tool_name")
                tool_params = result_data.get("parameters", {})

                tool_result = await self.tool_executor(
                    user_id, tool_name, tool_params
                )

                duration = (datetime.utcnow() - start_time).total_seconds() * 1000
                return ExecutionResult(
                    step_number=step.step_number,
                    success=tool_result.get("success", True),
                    output=tool_result,
                    tool_used=tool_name,
                    duration_ms=duration,
                )

            elif action == "response":
                duration = (datetime.utcnow() - start_time).total_seconds() * 1000
                return ExecutionResult(
                    step_number=step.step_number,
                    success=True,
                    output=result_data.get("content", ""),
                    duration_ms=duration,
                )

            else:  # error
                duration = (datetime.utcnow() - start_time).total_seconds() * 1000
                return ExecutionResult(
                    step_number=step.step_number,
                    success=False,
                    error=result_data.get("error", "Unknown error"),
                    duration_ms=duration,
                )

        except Exception as e:
            duration = (datetime.utcnow() - start_time).total_seconds() * 1000
            logger.error(f"Executor failed for step {step.step_number}: {e}")
            return ExecutionResult(
                step_number=step.step_number,
                success=False,
                error=str(e),
                duration_ms=duration,
            )

    async def _synthesize_response(
        self,
        user_id: UUID,
        session_id: UUID,
        original_request: str,
        plan: Optional[ExecutionPlan],
        execution_results: List[ExecutionResult],
    ) -> str:
        """Synthesize execution results into a natural user response."""
        # Build context for synthesis
        synthesis_prompt = f"""Synthesize these results into a natural response for the user.

ORIGINAL REQUEST: {original_request}

EXECUTION RESULTS:
"""
        for result in execution_results:
            status = "SUCCESS" if result.success else "FAILED"
            synthesis_prompt += f"\nStep {result.step_number} ({status}):\n"
            if result.output:
                output_str = (
                    json.dumps(result.output)
                    if isinstance(result.output, dict)
                    else str(result.output)
                )
                synthesis_prompt += f"  Output: {output_str[:500]}\n"
            if result.error:
                synthesis_prompt += f"  Error: {result.error}\n"

        synthesis_prompt += "\nGenerate a helpful, concise response for the user:"

        try:
            response = await self.anthropic.messages.create(
                model=self.model,
                max_tokens=1000,
                messages=[{"role": "user", "content": synthesis_prompt}],
            )

            return response.content[0].text

        except Exception as e:
            logger.error(f"Response synthesis failed: {e}")

            # Fallback: construct basic response
            if all(r.success for r in execution_results):
                return "I've completed your request successfully."
            else:
                return "I encountered some issues processing your request. Please try again."

    def _format_tools_for_planner(self, available_tools: List[Dict]) -> str:
        """Format tool definitions for the planner prompt."""
        lines = []
        for tool in available_tools:
            name = tool.get("name", "unknown")
            desc = tool.get("description", "No description")
            params = tool.get("input_schema", {}).get("properties", {})

            param_list = ", ".join(
                f"{k}: {v.get('type', 'any')}" for k, v in params.items()
            )

            lines.append(f"- {name}({param_list}): {desc}")

        return "\n".join(lines)
